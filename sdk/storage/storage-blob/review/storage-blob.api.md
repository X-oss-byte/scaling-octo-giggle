## API Report File for "@azure/storage-blob"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import { AbortSignalLike } from '@azure/abort-controller';
import { AzureLogger } from '@azure/logger';
import * as coreClient from '@azure/core-client';
import * as coreHttpCompat from '@azure/core-http-compat';
import * as coreRestPipeline from '@azure/core-rest-pipeline';
import { deserializationPolicy } from '@azure/core-client';
import { HttpClient } from '@azure/core-rest-pipeline';
import { HttpHeaders } from '@azure/core-rest-pipeline';
import { KeepAliveOptions } from '@azure/core-http-compat';
import { OperationTracingOptions } from '@azure/core-tracing';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { Pipeline as Pipeline_2 } from '@azure/core-rest-pipeline';
import { PipelinePolicy } from '@azure/core-rest-pipeline';
import { PipelineRequest } from '@azure/core-rest-pipeline';
import { PipelineResponse } from '@azure/core-rest-pipeline';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';
import { ProxySettings } from '@azure/core-rest-pipeline';
import { Readable } from 'stream';
import { RequestBodyType } from '@azure/core-rest-pipeline';
import { RestError } from '@azure/core-rest-pipeline';
import { SendRequest } from '@azure/core-rest-pipeline';
import { TokenCredential } from '@azure/core-auth';
import { TransferProgressEvent } from '@azure/core-rest-pipeline';
import { UserAgentPolicyOptions } from '@azure/core-rest-pipeline';

// @public
export interface AccessPolicy {
    expiresOn?: string;
    permissions?: string;
    startsOn?: string;
}

// @public
export type AccessTier = "P4" | "P6" | "P10" | "P15" | "P20" | "P30" | "P40" | "P50" | "P60" | "P70" | "P80" | "Hot" | "Cool" | "Archive";

// @public
export type AccountKind = "Storage" | "BlobStorage" | "StorageV2" | "FileStorage" | "BlockBlobStorage";

// @public
export class AccountSASPermissions {
    add: boolean;
    create: boolean;
    delete: boolean;
    deleteVersion: boolean;
    filter: boolean;
    static from(permissionLike: AccountSASPermissionsLike): AccountSASPermissions;
    list: boolean;
    static parse(permissions: string): AccountSASPermissions;
    permanentDelete: boolean;
    process: boolean;
    read: boolean;
    setImmutabilityPolicy: boolean;
    tag: boolean;
    toString(): string;
    update: boolean;
    write: boolean;
}

// @public
export interface AccountSASPermissionsLike {
    add?: boolean;
    create?: boolean;
    delete?: boolean;
    deleteVersion?: boolean;
    filter?: boolean;
    list?: boolean;
    permanentDelete?: boolean;
    process?: boolean;
    read?: boolean;
    setImmutabilityPolicy?: boolean;
    tag?: boolean;
    update?: boolean;
    write?: boolean;
}

// @public
export class AccountSASResourceTypes {
    container: boolean;
    object: boolean;
    static parse(resourceTypes: string): AccountSASResourceTypes;
    service: boolean;
    toString(): string;
}

// @public
export class AccountSASServices {
    blob: boolean;
    file: boolean;
    static parse(services: string): AccountSASServices;
    queue: boolean;
    table: boolean;
    toString(): string;
}

// @public
export interface AccountSASSignatureValues {
    encryptionScope?: string;
    expiresOn: Date;
    ipRange?: SasIPRange;
    permissions: AccountSASPermissions;
    protocol?: SASProtocol;
    resourceTypes: string;
    services: string;
    startsOn?: Date;
    version?: string;
}

// @public
export class AnonymousCredential extends Credential_2 {
    create(): AnonymousCredentialPolicy;
}

// @public
export class AnonymousCredentialPolicy extends CredentialPolicy {
    constructor();
    // (undocumented)
    name: string;
}

// @public
export interface AppendBlobAppendBlockFromUrlHeaders {
    blobAppendOffset?: string;
    blobCommittedBlockCount?: number;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    xMsContentCrc64?: Uint8Array;
}

// @public
export interface AppendBlobAppendBlockFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: AppendBlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
    sourceAuthorization?: HttpAuthorization;
    sourceConditions?: MatchConditions & ModificationConditions;
    sourceContentCrc64?: Uint8Array;
    sourceContentMD5?: Uint8Array;
}

// @public
export type AppendBlobAppendBlockFromUrlResponse = AppendBlobAppendBlockFromUrlHeaders;

// @public
export interface AppendBlobAppendBlockHeaders {
    blobAppendOffset?: string;
    blobCommittedBlockCount?: number;
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    xMsContentCrc64?: Uint8Array;
}

// @public
export interface AppendBlobAppendBlockOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: AppendBlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
    onProgress?: (progress: TransferProgressEvent) => void;
    transactionalContentCrc64?: Uint8Array;
    transactionalContentMD5?: Uint8Array;
}

// @public
export type AppendBlobAppendBlockResponse = AppendBlobAppendBlockHeaders;

// @public
export class AppendBlobClient extends BlobClient {
    constructor(connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions);
    constructor(url: string, credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: PipelineLike);
    appendBlock(body: RequestBodyType, contentLength: number, options?: AppendBlobAppendBlockOptions): Promise<AppendBlobAppendBlockResponse>;
    appendBlockFromURL(sourceURL: string, sourceOffset: number, count: number, options?: AppendBlobAppendBlockFromURLOptions): Promise<AppendBlobAppendBlockFromUrlResponse>;
    create(options?: AppendBlobCreateOptions): Promise<AppendBlobCreateResponse>;
    createIfNotExists(options?: AppendBlobCreateIfNotExistsOptions): Promise<AppendBlobCreateIfNotExistsResponse>;
    seal(options?: AppendBlobSealOptions): Promise<AppendBlobAppendBlockResponse>;
    withSnapshot(snapshot: string): AppendBlobClient;
}

// @public
export interface AppendBlobCreateHeaders {
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    versionId?: string;
}

// @public
export interface AppendBlobCreateIfNotExistsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
    immutabilityPolicy?: BlobImmutabilityPolicy;
    legalHold?: boolean;
    metadata?: Metadata;
}

// @public
export interface AppendBlobCreateIfNotExistsResponse extends AppendBlobCreateResponse {
    succeeded: boolean;
}

// @public
export interface AppendBlobCreateOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
    immutabilityPolicy?: BlobImmutabilityPolicy;
    legalHold?: boolean;
    metadata?: Metadata;
    tags?: Tags;
}

// @public
export type AppendBlobCreateResponse = AppendBlobCreateHeaders;

// @public
export interface AppendBlobRequestConditions extends BlobRequestConditions, AppendPositionAccessConditions {
}

// @public
export interface AppendBlobSealOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: AppendBlobRequestConditions;
}

// @public
export interface AppendPositionAccessConditions {
    appendPosition?: number;
    maxSize?: number;
}

// @public
export type ArchiveStatus = "rehydrate-pending-to-hot" | "rehydrate-pending-to-cool";

// @public
export interface BatchSubRequest {
    credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential;
    url: string;
}

// @public
export interface BatchSubResponse {
    bodyAsText?: string;
    errorCode?: string;
    headers: HttpHeaders;
    _request: BatchSubRequest;
    status: number;
    statusMessage: string;
}

// @public
export interface BlobAbortCopyFromURLHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface BlobAbortCopyFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: LeaseAccessConditions;
}

// @public
export type BlobAbortCopyFromURLResponse = BlobAbortCopyFromURLHeaders;

// @public
export interface BlobAcquireLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export class BlobBatch {
    constructor();
    deleteBlob(url: string, credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: BlobDeleteOptions): Promise<void>;
    deleteBlob(blobClient: BlobClient, options?: BlobDeleteOptions): Promise<void>;
    getHttpRequestBody(): string;
    getMultiPartContentType(): string;
    getSubRequests(): Map<number, BatchSubRequest>;
    setBlobAccessTier(url: string, credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, tier: AccessTier, options?: BlobSetTierOptions): Promise<void>;
    setBlobAccessTier(blobClient: BlobClient, tier: AccessTier, options?: BlobSetTierOptions): Promise<void>;
}

// @public
export class BlobBatchClient {
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: PipelineLike);
    createBatch(): BlobBatch;
    deleteBlobs(urls: string[], credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: BlobDeleteOptions): Promise<BlobBatchDeleteBlobsResponse>;
    deleteBlobs(blobClients: BlobClient[], options?: BlobDeleteOptions): Promise<BlobBatchDeleteBlobsResponse>;
    setBlobsAccessTier(urls: string[], credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, tier: AccessTier, options?: BlobSetTierOptions): Promise<BlobBatchSetBlobsAccessTierResponse>;
    setBlobsAccessTier(blobClients: BlobClient[], tier: AccessTier, options?: BlobSetTierOptions): Promise<BlobBatchSetBlobsAccessTierResponse>;
    submitBatch(batchRequest: BlobBatch, options?: BlobBatchSubmitBatchOptionalParams): Promise<BlobBatchSubmitBatchResponse>;
}

// @public
export type BlobBatchDeleteBlobsResponse = BlobBatchSubmitBatchResponse;

// @public
export type BlobBatchSetBlobsAccessTierResponse = BlobBatchSubmitBatchResponse;

// @public
export interface BlobBatchSubmitBatchOptionalParams extends ServiceSubmitBatchOptionalParamsModel {
}

// @public
export type BlobBatchSubmitBatchResponse = ParsedBatchResponse & ServiceSubmitBatchHeaders;

// @public
export interface BlobBeginCopyFromURLOptions extends BlobStartCopyFromURLOptions {
    intervalInMs?: number;
    onProgress?: (state: BlobBeginCopyFromUrlPollState) => void;
    resumeFrom?: string;
}

// @public
export interface BlobBeginCopyFromUrlPollState extends PollOperationState<BlobBeginCopyFromURLResponse> {
    readonly blobClient: CopyPollerBlobClient;
    copyId?: string;
    copyProgress?: string;
    copySource: string;
    readonly startCopyFromURLOptions?: BlobStartCopyFromURLOptions;
}

// @public
export interface BlobBeginCopyFromURLResponse extends BlobStartCopyFromURLResponse {
}

// @public
export interface BlobBreakLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface BlobChangeLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// Warning: (ae-forgotten-export) The symbol "StorageClient" needs to be exported by the entry point index.d.ts
//
// @public
export class BlobClient extends StorageClient {
    constructor(connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions);
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: PipelineLike);
    abortCopyFromURL(copyId: string, options?: BlobAbortCopyFromURLOptions): Promise<BlobAbortCopyFromURLResponse>;
    beginCopyFromURL(copySource: string, options?: BlobBeginCopyFromURLOptions): Promise<PollerLike<PollOperationState<BlobBeginCopyFromURLResponse>, BlobBeginCopyFromURLResponse>>;
    get containerName(): string;
    createSnapshot(options?: BlobCreateSnapshotOptions): Promise<BlobCreateSnapshotResponse>;
    delete(options?: BlobDeleteOptions): Promise<BlobDeleteResponse>;
    deleteIfExists(options?: BlobDeleteOptions): Promise<BlobDeleteIfExistsResponse>;
    deleteImmutabilityPolicy(options?: BlobDeleteImmutabilityPolicyOptions): Promise<BlobDeleteImmutabilityPolicyResponse>;
    download(offset?: number, count?: number, options?: BlobDownloadOptions): Promise<BlobDownloadResponseParsed>;
    downloadToBuffer(offset?: number, count?: number, options?: BlobDownloadToBufferOptions): Promise<Buffer>;
    downloadToBuffer(buffer: Buffer, offset?: number, count?: number, options?: BlobDownloadToBufferOptions): Promise<Buffer>;
    downloadToFile(filePath: string, offset?: number, count?: number, options?: BlobDownloadOptions): Promise<BlobDownloadResponseParsed>;
    exists(options?: BlobExistsOptions): Promise<boolean>;
    generateSasUrl(options: BlobGenerateSasUrlOptions): Promise<string>;
    getAppendBlobClient(): AppendBlobClient;
    getBlobLeaseClient(proposeLeaseId?: string): BlobLeaseClient;
    getBlockBlobClient(): BlockBlobClient;
    getPageBlobClient(): PageBlobClient;
    getProperties(options?: BlobGetPropertiesOptions): Promise<BlobGetPropertiesResponse>;
    getTags(options?: BlobGetTagsOptions): Promise<BlobGetTagsResponse>;
    get name(): string;
    setAccessTier(tier: BlockBlobTier | PremiumPageBlobTier | string, options?: BlobSetTierOptions): Promise<BlobSetTierResponse>;
    setHTTPHeaders(blobHTTPHeaders?: BlobHTTPHeaders, options?: BlobSetHTTPHeadersOptions): Promise<BlobSetHTTPHeadersResponse>;
    setImmutabilityPolicy(immutabilityPolicy: BlobImmutabilityPolicy, options?: BlobSetImmutabilityPolicyOptions): Promise<BlobSetImmutabilityPolicyResponse>;
    setLegalHold(legalHoldEnabled: boolean, options?: BlobSetLegalHoldOptions): Promise<BlobSetLegalHoldResponse>;
    setMetadata(metadata?: Metadata, options?: BlobSetMetadataOptions): Promise<BlobSetMetadataResponse>;
    setTags(tags: Tags, options?: BlobSetTagsOptions): Promise<BlobSetTagsResponse>;
    syncCopyFromURL(copySource: string, options?: BlobSyncCopyFromURLOptions): Promise<BlobCopyFromURLResponse>;
    undelete(options?: BlobUndeleteOptions): Promise<BlobUndeleteResponse>;
    withSnapshot(snapshot: string): BlobClient;
    withVersion(versionId: string): BlobClient;
}

// @public
export interface BlobCopyFromURLHeaders {
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    copyId?: string;
    copyStatus?: "success";
    date?: Date;
    encryptionScope?: string;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    versionId?: string;
    xMsContentCrc64?: Uint8Array;
}

// @public
export type BlobCopyFromURLResponse = BlobCopyFromURLHeaders;

// @public
export type BlobCopySourceTags = "REPLACE" | "COPY";

// @public
export interface BlobCreateSnapshotHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    snapshot?: string;
    version?: string;
    versionId?: string;
}

// @public
export interface BlobCreateSnapshotOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
    metadata?: Metadata;
}

// @public
export type BlobCreateSnapshotResponse = BlobCreateSnapshotHeaders;

// @public
export interface BlobDeleteHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface BlobDeleteIfExistsResponse extends BlobDeleteResponse {
    succeeded: boolean;
}

// @public
export interface BlobDeleteImmutabilityPolicyHeaders {
    clientRequestId?: string;
    date?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface BlobDeleteImmutabilityPolicyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type BlobDeleteImmutabilityPolicyResponse = BlobDeleteImmutabilityPolicyHeaders;

// @public
export interface BlobDeleteOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    deleteSnapshots?: DeleteSnapshotsOptionType;
}

// @public
export type BlobDeleteResponse = BlobDeleteHeaders;

// @public
export interface BlobDownloadHeaders {
    acceptRanges?: string;
    blobCommittedBlockCount?: number;
    blobContentMD5?: Uint8Array;
    blobSequenceNumber?: number;
    blobType?: BlobType;
    cacheControl?: string;
    clientRequestId?: string;
    contentCrc64?: Uint8Array;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentLength?: number;
    contentMD5?: Uint8Array;
    contentRange?: string;
    contentType?: string;
    copyCompletedOn?: Date;
    copyId?: string;
    copyProgress?: string;
    copySource?: string;
    copyStatus?: CopyStatusType;
    copyStatusDescription?: string;
    date?: Date;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    errorCode?: string;
    etag?: string;
    immutabilityPolicyExpiresOn?: Date;
    immutabilityPolicyMode?: BlobImmutabilityPolicyMode;
    isCurrentVersion?: boolean;
    isSealed?: boolean;
    isServerEncrypted?: boolean;
    lastAccessed?: Date;
    lastModified?: Date;
    leaseDuration?: LeaseDurationType;
    leaseState?: LeaseStateType;
    leaseStatus?: LeaseStatusType;
    legalHold?: boolean;
    // (undocumented)
    metadata?: {
        [propertyName: string]: string;
    };
    objectReplicationPolicyId?: string;
    objectReplicationRules?: {
        [propertyName: string]: string;
    };
    requestId?: string;
    tagCount?: number;
    version?: string;
    versionId?: string;
}

// @public
export interface BlobDownloadOptionalParams extends coreClient.OperationOptions {
    cpkInfo?: CpkInfo;
    leaseAccessConditions?: LeaseAccessConditions;
    modifiedAccessConditions?: ModifiedAccessConditionsModel;
    range?: string;
    rangeGetContentCRC64?: boolean;
    rangeGetContentMD5?: boolean;
    requestId?: string;
    snapshot?: string;
    timeoutInSeconds?: number;
    versionId?: string;
}

// @public
export interface BlobDownloadOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    maxRetryRequests?: number;
    onProgress?: (progress: TransferProgressEvent) => void;
    rangeGetContentCrc64?: boolean;
    rangeGetContentMD5?: boolean;
    snapshot?: string;
}

// Warning: (ae-forgotten-export) The symbol "BlobDownloadResponseModel" needs to be exported by the entry point index.d.ts
//
// @public
export interface BlobDownloadResponseParsed extends BlobDownloadResponseModel {
    objectReplicationDestinationPolicyId?: string;
    objectReplicationSourceProperties?: ObjectReplicationPolicy[];
}

// @public
export interface BlobDownloadToBufferOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blockSize?: number;
    concurrency?: number;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    maxRetryRequestsPerBlock?: number;
    onProgress?: (progress: TransferProgressEvent) => void;
}

// @public
export interface BlobExistsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
}

// @public
export interface BlobFlatListSegment {
    // (undocumented)
    blobItems: BlobItem[];
}

// @public (undocumented)
export interface BlobFlatListSegmentModel {
    // (undocumented)
    blobItems: BlobItemInternal[];
}

// @public
export interface BlobGenerateSasUrlOptions extends CommonGenerateSasUrlOptions {
    permissions?: BlobSASPermissions;
}

// @public
export interface BlobGetPropertiesHeaders {
    acceptRanges?: string;
    accessTier?: string;
    accessTierChangedOn?: Date;
    accessTierInferred?: boolean;
    archiveStatus?: string;
    blobCommittedBlockCount?: number;
    blobSequenceNumber?: number;
    blobType?: BlobType;
    cacheControl?: string;
    clientRequestId?: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentLength?: number;
    contentMD5?: Uint8Array;
    contentType?: string;
    copyCompletedOn?: Date;
    copyId?: string;
    copyProgress?: string;
    copySource?: string;
    copyStatus?: CopyStatusType;
    copyStatusDescription?: string;
    createdOn?: Date;
    date?: Date;
    destinationSnapshot?: string;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    errorCode?: string;
    etag?: string;
    expiresOn?: Date;
    immutabilityPolicyExpiresOn?: Date;
    immutabilityPolicyMode?: BlobImmutabilityPolicyMode;
    isCurrentVersion?: boolean;
    isIncrementalCopy?: boolean;
    isSealed?: boolean;
    isServerEncrypted?: boolean;
    lastAccessed?: Date;
    lastModified?: Date;
    leaseDuration?: LeaseDurationType;
    leaseState?: LeaseStateType;
    leaseStatus?: LeaseStatusType;
    legalHold?: boolean;
    // (undocumented)
    metadata?: {
        [propertyName: string]: string;
    };
    objectReplicationPolicyId?: string;
    objectReplicationRules?: {
        [propertyName: string]: string;
    };
    rehydratePriority?: RehydratePriority;
    requestId?: string;
    tagCount?: number;
    version?: string;
    versionId?: string;
}

// @public
export interface BlobGetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
}

// @public
export interface BlobGetPropertiesResponse extends BlobGetPropertiesResponseModel {
    objectReplicationDestinationPolicyId?: string;
    objectReplicationSourceProperties?: ObjectReplicationPolicy[];
}

// @public
export type BlobGetPropertiesResponseModel = BlobGetPropertiesHeaders;

// @public
export interface BlobGetTagsHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface BlobGetTagsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: TagConditions & LeaseAccessConditions;
}

// @public
export type BlobGetTagsResponse = {
    tags: Tags;
} & BlobGetTagsHeaders;

// @public
export interface BlobHierarchyListSegment {
    // (undocumented)
    blobItems: BlobItem[];
    // (undocumented)
    blobPrefixes?: BlobPrefix[];
}

// @public (undocumented)
export interface BlobHierarchyListSegmentModel {
    // (undocumented)
    blobItems: BlobItemInternal[];
    // (undocumented)
    blobPrefixes?: BlobPrefix[];
}

// @public
export interface BlobHTTPHeaders {
    blobCacheControl?: string;
    blobContentDisposition?: string;
    blobContentEncoding?: string;
    blobContentLanguage?: string;
    blobContentMD5?: Uint8Array;
    blobContentType?: string;
}

// @public
export interface BlobImmutabilityPolicy {
    expiriesOn?: Date;
    policyMode?: BlobImmutabilityPolicyMode;
}

// @public
export type BlobImmutabilityPolicyMode = "Mutable" | "Unlocked" | "Locked";

// @public
export interface BlobItem {
    // (undocumented)
    deleted: boolean;
    // (undocumented)
    hasVersionsOnly?: boolean;
    // (undocumented)
    isCurrentVersion?: boolean;
    // (undocumented)
    metadata?: {
        [propertyName: string]: string;
    };
    // (undocumented)
    name: string;
    // (undocumented)
    objectReplicationSourceProperties?: ObjectReplicationPolicy[];
    // (undocumented)
    properties: BlobProperties;
    // (undocumented)
    snapshot: string;
    // (undocumented)
    tags?: Tags;
    // (undocumented)
    versionId?: string;
}

// @public
export interface BlobItemInternal {
    blobTags?: BlobTags;
    // (undocumented)
    deleted: boolean;
    hasVersionsOnly?: boolean;
    // (undocumented)
    isCurrentVersion?: boolean;
    metadata?: {
        [propertyName: string]: string;
    };
    // (undocumented)
    name: string;
    objectReplicationMetadata?: {
        [propertyName: string]: string;
    };
    properties: BlobProperties;
    // (undocumented)
    snapshot: string;
    // (undocumented)
    versionId?: string;
}

// @public
export class BlobLeaseClient {
    constructor(client: ContainerClient | BlobClient, leaseId?: string);
    acquireLease(duration: number, options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    breakLease(breakPeriod: number, options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    changeLease(proposedLeaseId: string, options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    get leaseId(): string;
    releaseLease(options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    renewLease(options?: LeaseOperationOptions): Promise<Lease>;
    get url(): string;
}

// @public (undocumented)
export interface BlobPrefix {
    // (undocumented)
    name: string;
}

// @public
export interface BlobProperties {
    // (undocumented)
    accessTier?: AccessTier;
    // (undocumented)
    accessTierChangedOn?: Date;
    // (undocumented)
    accessTierInferred?: boolean;
    // (undocumented)
    archiveStatus?: ArchiveStatus;
    // (undocumented)
    blobSequenceNumber?: number;
    // (undocumented)
    blobType?: BlobType;
    // (undocumented)
    cacheControl?: string;
    // (undocumented)
    contentDisposition?: string;
    // (undocumented)
    contentEncoding?: string;
    // (undocumented)
    contentLanguage?: string;
    contentLength?: number;
    // (undocumented)
    contentMD5?: Uint8Array;
    // (undocumented)
    contentType?: string;
    // (undocumented)
    copyCompletedOn?: Date;
    // (undocumented)
    copyId?: string;
    // (undocumented)
    copyProgress?: string;
    // (undocumented)
    copySource?: string;
    // (undocumented)
    copyStatus?: CopyStatusType;
    // (undocumented)
    copyStatusDescription?: string;
    // (undocumented)
    createdOn?: Date;
    // (undocumented)
    customerProvidedKeySha256?: string;
    // (undocumented)
    deletedOn?: Date;
    // (undocumented)
    destinationSnapshot?: string;
    encryptionScope?: string;
    // (undocumented)
    etag: string;
    // (undocumented)
    expiresOn?: Date;
    immutabilityPolicyExpiresOn?: Date;
    immutabilityPolicyMode?: BlobImmutabilityPolicyMode;
    // (undocumented)
    incrementalCopy?: boolean;
    // (undocumented)
    isSealed?: boolean;
    // (undocumented)
    lastAccessedOn?: Date;
    // (undocumented)
    lastModified: Date;
    // (undocumented)
    leaseDuration?: LeaseDurationType;
    // (undocumented)
    leaseState?: LeaseStateType;
    // (undocumented)
    leaseStatus?: LeaseStatusType;
    legalHold?: boolean;
    rehydratePriority?: RehydratePriority;
    // (undocumented)
    remainingRetentionDays?: number;
    // (undocumented)
    serverEncrypted?: boolean;
    // (undocumented)
    tagCount?: number;
}

// @public
export interface BlobQueryArrowConfiguration {
    kind: "arrow";
    schema: BlobQueryArrowField[];
}

// @public
export interface BlobQueryArrowField {
    name?: string;
    precision?: number;
    scale?: number;
    type: BlobQueryArrowFieldType;
}

// @public
export type BlobQueryArrowFieldType = "int64" | "bool" | "timestamp[ms]" | "string" | "double" | "decimal";

// @public
export interface BlobQueryCsvTextConfiguration {
    columnSeparator?: string;
    escapeCharacter?: string;
    fieldQuote?: string;
    hasHeaders?: boolean;
    kind: "csv";
    recordSeparator: string;
}

// @public
export interface BlobQueryError {
    description: string;
    isFatal: boolean;
    name: string;
    position: number;
}

// @public
export interface BlobQueryHeaders {
    acceptRanges?: string;
    blobCommittedBlockCount?: number;
    blobContentMD5?: Uint8Array;
    blobSequenceNumber?: number;
    blobType?: BlobType;
    cacheControl?: string;
    clientRequestId?: string;
    contentCrc64?: Uint8Array;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentLength?: number;
    contentMD5?: Uint8Array;
    contentRange?: string;
    contentType?: string;
    copyCompletionTime?: Date;
    copyId?: string;
    copyProgress?: string;
    copySource?: string;
    copyStatus?: CopyStatusType;
    copyStatusDescription?: string;
    date?: Date;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    leaseDuration?: LeaseDurationType;
    leaseState?: LeaseStateType;
    leaseStatus?: LeaseStatusType;
    // (undocumented)
    metadata?: {
        [propertyName: string]: string;
    };
    requestId?: string;
    version?: string;
}

// @public
export interface BlobQueryJsonTextConfiguration {
    kind: "json";
    recordSeparator: string;
}

// @public
export interface BlobQueryParquetConfiguration {
    kind: "parquet";
}

// @public
export interface BlobReleaseLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface BlobRenewLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface BlobRequestConditions extends ModifiedAccessConditions, LeaseAccessConditions {
}

// @public
export class BlobSASPermissions {
    add: boolean;
    create: boolean;
    delete: boolean;
    deleteVersion: boolean;
    execute: boolean;
    static from(permissionLike: BlobSASPermissionsLike): BlobSASPermissions;
    move: boolean;
    static parse(permissions: string): BlobSASPermissions;
    permanentDelete: boolean;
    read: boolean;
    setImmutabilityPolicy: boolean;
    tag: boolean;
    toString(): string;
    write: boolean;
}

// @public
export interface BlobSASPermissionsLike {
    add?: boolean;
    create?: boolean;
    delete?: boolean;
    deleteVersion?: boolean;
    execute?: boolean;
    move?: boolean;
    permanentDelete?: boolean;
    read?: boolean;
    setImmutabilityPolicy?: boolean;
    tag?: boolean;
    write?: boolean;
}

// @public
export interface BlobSASSignatureValues {
    blobName?: string;
    cacheControl?: string;
    containerName: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentType?: string;
    correlationId?: string;
    encryptionScope?: string;
    expiresOn?: Date;
    identifier?: string;
    ipRange?: SasIPRange;
    permissions?: BlobSASPermissions | ContainerSASPermissions;
    preauthorizedAgentObjectId?: string;
    protocol?: SASProtocol;
    snapshotTime?: string;
    startsOn?: Date;
    version?: string;
    versionId?: string;
}

// @public
export class BlobServiceClient extends StorageClient {
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: PipelineLike);
    createContainer(containerName: string, options?: ContainerCreateOptions): Promise<{
        containerClient: ContainerClient;
        containerCreateResponse: ContainerCreateResponse;
    }>;
    deleteContainer(containerName: string, options?: ContainerDeleteMethodOptions): Promise<ContainerDeleteResponse>;
    findBlobsByTags(tagFilterSqlExpression: string, options?: ServiceFindBlobByTagsOptions): PagedAsyncIterableIterator<FilterBlobItem, ServiceFindBlobsByTagsSegmentResponse>;
    static fromConnectionString(connectionString: string, options?: StoragePipelineOptions): BlobServiceClient;
    generateAccountSasUrl(expiresOn?: Date, permissions?: AccountSASPermissions, resourceTypes?: string, options?: ServiceGenerateAccountSasUrlOptions): string;
    getAccountInfo(options?: ServiceGetAccountInfoOptions): Promise<ServiceGetAccountInfoResponse>;
    getBlobBatchClient(): BlobBatchClient;
    getContainerClient(containerName: string): ContainerClient;
    getProperties(options?: ServiceGetPropertiesOptions): Promise<ServiceGetPropertiesResponse>;
    getStatistics(options?: ServiceGetStatisticsOptions): Promise<ServiceGetStatisticsResponse>;
    getUserDelegationKey(startsOn: Date, expiresOn: Date, options?: ServiceGetUserDelegationKeyOptions): Promise<ServiceGetUserDelegationKeyResponse>;
    listContainers(options?: ServiceListContainersOptions): PagedAsyncIterableIterator<ContainerItem, ServiceListContainersSegmentResponse>;
    setProperties(properties: BlobServiceProperties, options?: ServiceSetPropertiesOptions): Promise<ServiceSetPropertiesResponse>;
    undeleteContainer(deletedContainerName: string, deletedContainerVersion: string, options?: ServiceUndeleteContainerOptions): Promise<{
        containerClient: ContainerClient;
        containerUndeleteResponse: ContainerUndeleteResponse;
    }>;
}

// @public
export interface BlobServiceProperties {
    blobAnalyticsLogging?: Logging;
    cors?: CorsRule[];
    defaultServiceVersion?: string;
    deleteRetentionPolicy?: RetentionPolicy;
    hourMetrics?: Metrics;
    minuteMetrics?: Metrics;
    staticWebsite?: StaticWebsite;
}

// @public
export interface BlobServiceStatistics {
    geoReplication?: GeoReplication;
}

// @public
export interface BlobSetHTTPHeadersHeaders {
    blobSequenceNumber?: number;
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface BlobSetHTTPHeadersOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
}

// @public
export type BlobSetHTTPHeadersResponse = BlobSetHTTPHeadersHeaders;

// @public
export interface BlobSetImmutabilityPolicyHeaders {
    clientRequestId?: string;
    date?: Date;
    immutabilityPolicyExpiry?: Date;
    immutabilityPolicyMode?: BlobImmutabilityPolicyMode;
    requestId?: string;
    version?: string;
}

// @public
export interface BlobSetImmutabilityPolicyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    // (undocumented)
    modifiedAccessCondition?: ModificationConditions;
}

// @public
export type BlobSetImmutabilityPolicyResponse = BlobSetImmutabilityPolicyHeaders;

// @public
export interface BlobSetLegalHoldHeaders {
    clientRequestId?: string;
    date?: Date;
    legalHold?: boolean;
    requestId?: string;
    version?: string;
}

// @public
export interface BlobSetLegalHoldOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type BlobSetLegalHoldResponse = BlobSetLegalHoldHeaders;

// @public
export interface BlobSetMetadataHeaders {
    clientRequestId?: string;
    date?: Date;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    versionId?: string;
}

// @public
export interface BlobSetMetadataOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
}

// @public
export type BlobSetMetadataResponse = BlobSetMetadataHeaders;

// @public
export interface BlobSetTagsHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface BlobSetTagsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: TagConditions & LeaseAccessConditions;
}

// @public
export type BlobSetTagsResponse = BlobSetTagsHeaders;

// @public
export interface BlobSetTierHeaders {
    clientRequestId?: string;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface BlobSetTierOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: LeaseAccessConditions & TagConditions;
    rehydratePriority?: RehydratePriority;
}

// @public
export type BlobSetTierResponse = BlobSetTierHeaders;

// @public
export interface BlobStartCopyFromURLHeaders {
    clientRequestId?: string;
    copyId?: string;
    copyStatus?: CopyStatusType;
    date?: Date;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    versionId?: string;
}

// @public
export interface BlobStartCopyFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    immutabilityPolicy?: BlobImmutabilityPolicy;
    legalHold?: boolean;
    metadata?: Metadata;
    rehydratePriority?: RehydratePriority;
    sealBlob?: boolean;
    sourceConditions?: ModifiedAccessConditions;
    tags?: Tags;
    tier?: BlockBlobTier | PremiumPageBlobTier | string;
}

// @public
export type BlobStartCopyFromURLResponse = BlobStartCopyFromURLHeaders;

// @public
export interface BlobSyncCopyFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    copySourceTags?: BlobCopySourceTags;
    encryptionScope?: string;
    immutabilityPolicy?: BlobImmutabilityPolicy;
    legalHold?: boolean;
    metadata?: Metadata;
    sourceAuthorization?: HttpAuthorization;
    sourceConditions?: MatchConditions & ModificationConditions;
    sourceContentMD5?: Uint8Array;
    tags?: Tags;
}

// @public (undocumented)
export interface BlobTag {
    // (undocumented)
    key: string;
    // (undocumented)
    value: string;
}

// @public
export interface BlobTags {
    // (undocumented)
    blobTagSet: BlobTag[];
}

// @public
export type BlobType = "BlockBlob" | "PageBlob" | "AppendBlob";

// @public
export interface BlobUndeleteHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface BlobUndeleteOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    customerProvidedKey?: CpkInfo;
}

// @public
export type BlobUndeleteResponse = BlobUndeleteHeaders;

// @public
export type BlobUploadCommonResponse = BlockBlobUploadHeaders;

// @public
export interface Block {
    name: string;
    size: number;
}

// @public
export class BlockBlobClient extends BlobClient {
    constructor(connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions);
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: PipelineLike);
    commitBlockList(blocks: string[], options?: BlockBlobCommitBlockListOptions): Promise<BlockBlobCommitBlockListResponse>;
    getBlockList(listType: BlockListType, options?: BlockBlobGetBlockListOptions): Promise<BlockBlobGetBlockListResponse>;
    query(query: string, options?: BlockBlobQueryOptions): Promise<BlobDownloadResponseModel>;
    stageBlock(blockId: string, body: RequestBodyType, contentLength: number, options?: BlockBlobStageBlockOptions): Promise<BlockBlobStageBlockResponse>;
    stageBlockFromURL(blockId: string, sourceURL: string, offset?: number, count?: number, options?: BlockBlobStageBlockFromURLOptions): Promise<BlockBlobStageBlockFromURLResponse>;
    syncUploadFromURL(sourceURL: string, options?: BlockBlobSyncUploadFromURLOptions): Promise<BlockBlobPutBlobFromUrlResponse>;
    upload(body: RequestBodyType, contentLength: number, options?: BlockBlobUploadOptions): Promise<BlockBlobUploadResponse>;
    // @deprecated
    uploadBrowserData(browserData: Blob | ArrayBuffer | ArrayBufferView, options?: BlockBlobParallelUploadOptions): Promise<BlobUploadCommonResponse>;
    uploadData(data: Buffer | Blob | ArrayBuffer | ArrayBufferView, options?: BlockBlobParallelUploadOptions): Promise<BlobUploadCommonResponse>;
    uploadFile(filePath: string, options?: BlockBlobParallelUploadOptions): Promise<BlobUploadCommonResponse>;
    uploadStream(stream: Readable, bufferSize?: number, maxConcurrency?: number, options?: BlockBlobUploadStreamOptions): Promise<BlobUploadCommonResponse>;
    withSnapshot(snapshot: string): BlockBlobClient;
}

// @public
export interface BlockBlobCommitBlockListHeaders {
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    versionId?: string;
    xMsContentCrc64?: Uint8Array;
}

// @public
export interface BlockBlobCommitBlockListOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
    immutabilityPolicy?: BlobImmutabilityPolicy;
    legalHold?: boolean;
    metadata?: Metadata;
    tags?: Tags;
    tier?: BlockBlobTier | string;
}

// @public
export type BlockBlobCommitBlockListResponse = BlockBlobCommitBlockListHeaders;

// @public
export interface BlockBlobGetBlockListHeaders {
    blobContentLength?: number;
    clientRequestId?: string;
    contentType?: string;
    date?: Date;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface BlockBlobGetBlockListOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: LeaseAccessConditions & TagConditions;
}

// @public
export type BlockBlobGetBlockListResponse = BlockBlobGetBlockListHeaders & BlockList;

// @public
export interface BlockBlobParallelUploadOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    blockSize?: number;
    concurrency?: number;
    conditions?: BlobRequestConditions;
    encryptionScope?: string;
    maxSingleShotSize?: number;
    metadata?: {
        [propertyName: string]: string;
    };
    onProgress?: (progress: TransferProgressEvent) => void;
    tags?: Tags;
    tier?: BlockBlobTier | string;
}

// @public
export interface BlockBlobPutBlobFromUrlHeaders {
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    versionId?: string;
}

// @public
export type BlockBlobPutBlobFromUrlResponse = BlockBlobPutBlobFromUrlHeaders;

// @public
export interface BlockBlobQueryOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    inputTextConfiguration?: BlobQueryJsonTextConfiguration | BlobQueryCsvTextConfiguration | BlobQueryParquetConfiguration;
    onError?: (error: BlobQueryError) => void;
    onProgress?: (progress: TransferProgressEvent) => void;
    outputTextConfiguration?: BlobQueryJsonTextConfiguration | BlobQueryCsvTextConfiguration | BlobQueryArrowConfiguration;
}

// @public
export interface BlockBlobStageBlockFromURLHeaders {
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    errorCode?: string;
    isServerEncrypted?: boolean;
    requestId?: string;
    version?: string;
    xMsContentCrc64?: Uint8Array;
}

// @public
export interface BlockBlobStageBlockFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: LeaseAccessConditions;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
    range?: Range_2;
    sourceAuthorization?: HttpAuthorization;
    sourceContentCrc64?: Uint8Array;
    sourceContentMD5?: Uint8Array;
}

// @public
export type BlockBlobStageBlockFromURLResponse = BlockBlobStageBlockFromURLHeaders;

// @public
export interface BlockBlobStageBlockHeaders {
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    errorCode?: string;
    isServerEncrypted?: boolean;
    requestId?: string;
    version?: string;
    xMsContentCrc64?: Uint8Array;
}

// @public
export interface BlockBlobStageBlockOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: LeaseAccessConditions;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
    onProgress?: (progress: TransferProgressEvent) => void;
    transactionalContentCrc64?: Uint8Array;
    transactionalContentMD5?: Uint8Array;
}

// @public
export type BlockBlobStageBlockResponse = BlockBlobStageBlockHeaders;

// @public
export interface BlockBlobSyncUploadFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    conditions?: BlobRequestConditions;
    copySourceBlobProperties?: boolean;
    copySourceTags?: BlobCopySourceTags;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
    metadata?: Metadata;
    sourceAuthorization?: HttpAuthorization;
    sourceConditions?: ModifiedAccessConditions;
    sourceContentMD5?: Uint8Array;
    tags?: Tags;
    tier?: BlockBlobTier | string;
    timeoutInSeconds?: number;
}

// @public
export enum BlockBlobTier {
    Archive = "Archive",
    Cool = "Cool",
    Hot = "Hot"
}

// @public
export interface BlockBlobUploadHeaders {
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    versionId?: string;
}

// @public
export interface BlockBlobUploadOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
    immutabilityPolicy?: BlobImmutabilityPolicy;
    legalHold?: boolean;
    metadata?: Metadata;
    onProgress?: (progress: TransferProgressEvent) => void;
    tags?: Tags;
    tier?: BlockBlobTier | string;
}

// @public
export type BlockBlobUploadResponse = BlockBlobUploadHeaders;

// @public
export interface BlockBlobUploadStreamOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    conditions?: BlobRequestConditions;
    encryptionScope?: string;
    metadata?: {
        [propertyName: string]: string;
    };
    onProgress?: (progress: TransferProgressEvent) => void;
    tags?: Tags;
    tier?: BlockBlobTier | string;
}

// @public (undocumented)
export interface BlockList {
    // (undocumented)
    committedBlocks?: Block[];
    // (undocumented)
    uncommittedBlocks?: Block[];
}

// @public
export type BlockListType = "committed" | "uncommitted" | "all";

// @public
export interface CommonGenerateSasUrlOptions {
    cacheControl?: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentType?: string;
    encryptionScope?: string;
    expiresOn?: Date;
    identifier?: string;
    ipRange?: SasIPRange;
    protocol?: SASProtocol;
    startsOn?: Date;
    version?: string;
}

// @public
export interface CommonOptions {
    tracingOptions?: OperationTracingOptions;
}

// @public
export interface ContainerAcquireLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface ContainerBreakLeaseOptionalParams extends coreClient.OperationOptions {
    breakPeriod?: number;
    modifiedAccessConditions?: ModifiedAccessConditionsModel;
    requestId?: string;
    timeoutInSeconds?: number;
}

// @public
export interface ContainerBreakLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface ContainerChangeLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export class ContainerClient extends StorageClient {
    constructor(connectionString: string, containerName: string, options?: StoragePipelineOptions);
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: PipelineLike);
    get containerName(): string;
    create(options?: ContainerCreateOptions): Promise<ContainerCreateResponse>;
    createIfNotExists(options?: ContainerCreateOptions): Promise<ContainerCreateIfNotExistsResponse>;
    delete(options?: ContainerDeleteMethodOptions): Promise<ContainerDeleteResponse>;
    deleteBlob(blobName: string, options?: ContainerDeleteBlobOptions): Promise<BlobDeleteResponse>;
    deleteIfExists(options?: ContainerDeleteMethodOptions): Promise<ContainerDeleteIfExistsResponse>;
    exists(options?: ContainerExistsOptions): Promise<boolean>;
    findBlobsByTags(tagFilterSqlExpression: string, options?: ContainerFindBlobByTagsOptions): PagedAsyncIterableIterator<FilterBlobItem, ContainerFindBlobsByTagsSegmentResponse>;
    generateSasUrl(options: ContainerGenerateSasUrlOptions): Promise<string>;
    getAccessPolicy(options?: ContainerGetAccessPolicyOptions): Promise<ContainerGetAccessPolicyResponse>;
    getAppendBlobClient(blobName: string): AppendBlobClient;
    getBlobBatchClient(): BlobBatchClient;
    getBlobClient(blobName: string): BlobClient;
    getBlobLeaseClient(proposeLeaseId?: string): BlobLeaseClient;
    getBlockBlobClient(blobName: string): BlockBlobClient;
    getPageBlobClient(blobName: string): PageBlobClient;
    getProperties(options?: ContainerGetPropertiesOptions): Promise<ContainerGetPropertiesResponse>;
    listBlobsByHierarchy(delimiter: string, options?: ContainerListBlobsOptions): PagedAsyncIterableIterator<({
        kind: "prefix";
    } & BlobPrefix) | ({
        kind: "blob";
    } & BlobItem), ContainerListBlobHierarchySegmentResponse>;
    listBlobsFlat(options?: ContainerListBlobsOptions): PagedAsyncIterableIterator<BlobItem, ContainerListBlobFlatSegmentResponse>;
    setAccessPolicy(access?: PublicAccessType, containerAcl?: SignedIdentifier[], options?: ContainerSetAccessPolicyOptions): Promise<ContainerSetAccessPolicyResponse>;
    setMetadata(metadata?: Metadata, options?: ContainerSetMetadataOptions): Promise<ContainerSetMetadataResponse>;
    uploadBlockBlob(blobName: string, body: RequestBodyType, contentLength: number, options?: BlockBlobUploadOptions): Promise<{
        blockBlobClient: BlockBlobClient;
        response: BlockBlobUploadResponse;
    }>;
}

// @public
export interface ContainerCreateHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface ContainerCreateIfNotExistsResponse extends ContainerCreateResponse {
    succeeded: boolean;
}

// @public
export interface ContainerCreateOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    access?: PublicAccessType;
    containerEncryptionScope?: ContainerEncryptionScope;
    metadata?: Metadata;
}

// @public
export type ContainerCreateResponse = ContainerCreateHeaders;

// @public
export interface ContainerDeleteBlobOptions extends BlobDeleteOptions {
    versionId?: string;
}

// @public
export interface ContainerDeleteHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ContainerDeleteIfExistsResponse extends ContainerDeleteResponse {
    succeeded: boolean;
}

// @public
export interface ContainerDeleteMethodOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ContainerRequestConditions;
}

// @public
export type ContainerDeleteResponse = ContainerDeleteHeaders;

// @public
export interface ContainerEncryptionScope {
    defaultEncryptionScope?: string;
    preventEncryptionScopeOverride?: boolean;
}

// @public
export interface ContainerExistsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export interface ContainerFilterBlobsHeaders {
    clientRequestId?: string;
    date?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface ContainerFindBlobByTagsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ContainerFindBlobsByTagsSegmentResponse = FilterBlobSegment & ContainerFilterBlobsHeaders;

// @public
export interface ContainerGenerateSasUrlOptions extends CommonGenerateSasUrlOptions {
    permissions?: ContainerSASPermissions;
}

// @public
export interface ContainerGetAccessPolicyHeaders {
    blobPublicAccess?: PublicAccessType;
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface ContainerGetAccessPolicyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: LeaseAccessConditions;
}

// @public
export type ContainerGetAccessPolicyResponse = {
    signedIdentifiers: SignedIdentifier[];
} & ContainerGetAccessPolicyHeaders;

// @public
export interface ContainerGetPropertiesHeaders {
    blobPublicAccess?: PublicAccessType;
    clientRequestId?: string;
    date?: Date;
    defaultEncryptionScope?: string;
    denyEncryptionScopeOverride?: boolean;
    errorCode?: string;
    etag?: string;
    hasImmutabilityPolicy?: boolean;
    hasLegalHold?: boolean;
    isImmutableStorageWithVersioningEnabled?: boolean;
    lastModified?: Date;
    leaseDuration?: LeaseDurationType;
    leaseState?: LeaseStateType;
    leaseStatus?: LeaseStatusType;
    // (undocumented)
    metadata?: {
        [propertyName: string]: string;
    };
    requestId?: string;
    version?: string;
}

// @public
export interface ContainerGetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: LeaseAccessConditions;
}

// @public
export type ContainerGetPropertiesResponse = ContainerGetPropertiesHeaders;

// @public
export interface ContainerItem {
    // (undocumented)
    deleted?: boolean;
    metadata?: {
        [propertyName: string]: string;
    };
    // (undocumented)
    name: string;
    properties: ContainerProperties;
    // (undocumented)
    version?: string;
}

// @public
export interface ContainerListBlobFlatSegmentHeaders {
    clientRequestId?: string;
    contentType?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export type ContainerListBlobFlatSegmentResponse = ListBlobsFlatSegmentResponse & ContainerListBlobFlatSegmentHeaders;

// @public
export interface ContainerListBlobHierarchySegmentHeaders {
    clientRequestId?: string;
    contentType?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export type ContainerListBlobHierarchySegmentResponse = ListBlobsHierarchySegmentResponse & ContainerListBlobHierarchySegmentHeaders;

// @public
export interface ContainerListBlobsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    includeCopy?: boolean;
    includeDeleted?: boolean;
    includeDeletedWithVersions?: boolean;
    includeImmutabilityPolicy?: boolean;
    includeLegalHold?: boolean;
    includeMetadata?: boolean;
    includeSnapshots?: boolean;
    includeTags?: boolean;
    includeUncommitedBlobs?: boolean;
    includeVersions?: boolean;
    prefix?: string;
}

// @public
export interface ContainerProperties {
    // (undocumented)
    defaultEncryptionScope?: string;
    // (undocumented)
    deletedOn?: Date;
    // (undocumented)
    etag: string;
    // (undocumented)
    hasImmutabilityPolicy?: boolean;
    // (undocumented)
    hasLegalHold?: boolean;
    isImmutableStorageWithVersioningEnabled?: boolean;
    // (undocumented)
    lastModified: Date;
    // (undocumented)
    leaseDuration?: LeaseDurationType;
    // (undocumented)
    leaseState?: LeaseStateType;
    // (undocumented)
    leaseStatus?: LeaseStatusType;
    // (undocumented)
    preventEncryptionScopeOverride?: boolean;
    // (undocumented)
    publicAccess?: PublicAccessType;
    // (undocumented)
    remainingRetentionDays?: number;
}

// @public
export interface ContainerReleaseLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface ContainerRenameHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export type ContainerRenameResponse = ContainerRenameHeaders;

// @public
export interface ContainerRenewLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface ContainerRequestConditions extends LeaseAccessConditions, ModificationConditions {
}

// @public
export class ContainerSASPermissions {
    add: boolean;
    create: boolean;
    delete: boolean;
    deleteVersion: boolean;
    execute: boolean;
    filterByTags: boolean;
    static from(permissionLike: ContainerSASPermissionsLike): ContainerSASPermissions;
    list: boolean;
    move: boolean;
    static parse(permissions: string): ContainerSASPermissions;
    permanentDelete: boolean;
    read: boolean;
    setImmutabilityPolicy: boolean;
    tag: boolean;
    toString(): string;
    write: boolean;
}

// @public
export interface ContainerSASPermissionsLike {
    add?: boolean;
    create?: boolean;
    delete?: boolean;
    deleteVersion?: boolean;
    execute?: boolean;
    filterByTags?: boolean;
    list?: boolean;
    move?: boolean;
    permanentDelete?: boolean;
    read?: boolean;
    setImmutabilityPolicy?: boolean;
    tag?: boolean;
    write?: boolean;
}

// @public
export interface ContainerSetAccessPolicyHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface ContainerSetAccessPolicyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ContainerRequestConditions;
}

// @public
export type ContainerSetAccessPolicyResponse = ContainerSetAccessPolicyHeaders;

// @public
export interface ContainerSetMetadataHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface ContainerSetMetadataOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ContainerRequestConditions;
}

// @public
export type ContainerSetMetadataResponse = ContainerSetMetadataHeaders;

// @public
export interface ContainerUndeleteHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export type ContainerUndeleteResponse = ContainerUndeleteHeaders;

// @public
export type CopyPollerBlobClient = Pick<BlobClient, "abortCopyFromURL" | "getProperties"> & {
    startCopyFromURL(copySource: string, options?: BlobStartCopyFromURLOptions): Promise<BlobBeginCopyFromURLResponse>;
};

// @public
export type CopyStatusType = "pending" | "success" | "aborted" | "failed";

// @public
export interface CorsRule {
    allowedHeaders: string;
    allowedMethods: string;
    allowedOrigins: string;
    exposedHeaders: string;
    maxAgeInSeconds: number;
}

// @public
export interface CpkInfo {
    encryptionAlgorithm?: EncryptionAlgorithmType;
    encryptionKey?: string;
    encryptionKeySha256?: string;
}

// @public
abstract class Credential_2 {
    create(): PipelinePolicy;
}
export { Credential_2 as Credential }

// @public
export abstract class CredentialPolicy implements PipelinePolicy {
    // (undocumented)
    name: string;
    sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse>;
    protected signRequest(request: PipelineRequest): PipelineRequest;
}

// @public
export type CredentialPolicyCreator = () => CredentialPolicy;

// @public
export type DeleteSnapshotsOptionType = "include" | "only";

export { deserializationPolicy }

// @public
export type EncryptionAlgorithmType = string;

// @public
export interface FilterBlobItem {
    containerName: string;
    name: string;
    tags?: Tags;
    // @deprecated
    tagValue: string;
}

// @public
export interface FilterBlobItemModel {
    // (undocumented)
    containerName: string;
    // (undocumented)
    name: string;
    tags?: BlobTags;
}

// @public
export interface FilterBlobSegment {
    // (undocumented)
    blobs: FilterBlobItem[];
    // (undocumented)
    continuationToken?: string;
    // (undocumented)
    serviceEndpoint: string;
    // (undocumented)
    where: string;
}

// @public
export interface FilterBlobSegmentModel {
    // (undocumented)
    blobs: FilterBlobItemModel[];
    // (undocumented)
    continuationToken?: string;
    // (undocumented)
    serviceEndpoint: string;
    // (undocumented)
    where: string;
}

// @public
export function generateAccountSASQueryParameters(accountSASSignatureValues: AccountSASSignatureValues, sharedKeyCredential: StorageSharedKeyCredential): SASQueryParameters;

// @public
export function generateBlobSASQueryParameters(blobSASSignatureValues: BlobSASSignatureValues, sharedKeyCredential: StorageSharedKeyCredential): SASQueryParameters;

// @public
export function generateBlobSASQueryParameters(blobSASSignatureValues: BlobSASSignatureValues, userDelegationKey: UserDelegationKey, accountName: string): SASQueryParameters;

// @public
export interface GeoReplication {
    lastSyncOn: Date;
    status: GeoReplicationStatusType;
}

// @public
export type GeoReplicationStatusType = "live" | "bootstrap" | "unavailable";

// @public
export interface HttpAuthorization {
    scheme: string;
    value: string;
}

export { HttpClient }

export { HttpHeaders }

// @public
export function isPipelineLike(pipeline: unknown): pipeline is PipelineLike;

// @public
export interface Lease {
    date?: Date;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    leaseId?: string;
    leaseTime?: number;
    requestId?: string;
    version?: string;
}

// @public
export interface LeaseAccessConditions {
    leaseId?: string;
}

// @public
export type LeaseDurationType = "infinite" | "fixed";

// @public
export interface LeaseOperationOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export type LeaseOperationResponse = Lease;

// @public
export type LeaseStateType = "available" | "leased" | "expired" | "breaking" | "broken";

// @public
export type LeaseStatusType = "locked" | "unlocked";

// @public
export interface ListBlobsFlatSegmentResponse {
    // (undocumented)
    containerName: string;
    // (undocumented)
    continuationToken?: string;
    // (undocumented)
    marker?: string;
    // (undocumented)
    maxPageSize?: number;
    // (undocumented)
    prefix?: string;
    // (undocumented)
    segment: BlobFlatListSegment;
    // (undocumented)
    serviceEndpoint: string;
}

// @public
export interface ListBlobsFlatSegmentResponseModel {
    // (undocumented)
    containerName: string;
    // (undocumented)
    continuationToken?: string;
    // (undocumented)
    marker?: string;
    // (undocumented)
    maxPageSize?: number;
    // (undocumented)
    prefix?: string;
    // (undocumented)
    segment: BlobFlatListSegmentModel;
    // (undocumented)
    serviceEndpoint: string;
}

// @public
export interface ListBlobsHierarchySegmentResponse {
    // (undocumented)
    containerName: string;
    // (undocumented)
    continuationToken?: string;
    // (undocumented)
    delimiter?: string;
    // (undocumented)
    marker?: string;
    // (undocumented)
    maxPageSize?: number;
    // (undocumented)
    prefix?: string;
    // (undocumented)
    segment: BlobHierarchyListSegment;
    // (undocumented)
    serviceEndpoint: string;
}

// @public
export interface ListBlobsHierarchySegmentResponseModel {
    // (undocumented)
    containerName: string;
    // (undocumented)
    continuationToken?: string;
    // (undocumented)
    delimiter?: string;
    // (undocumented)
    marker?: string;
    // (undocumented)
    maxPageSize?: number;
    // (undocumented)
    prefix?: string;
    // (undocumented)
    segment: BlobHierarchyListSegmentModel;
    // (undocumented)
    serviceEndpoint: string;
}

// @public
export interface ListContainersSegmentResponse {
    // (undocumented)
    containerItems: ContainerItem[];
    // (undocumented)
    continuationToken?: string;
    // (undocumented)
    marker?: string;
    // (undocumented)
    maxPageSize?: number;
    // (undocumented)
    prefix?: string;
    // (undocumented)
    serviceEndpoint: string;
}

// @public
export const logger: AzureLogger;

// @public
export interface Logging {
    deleteProperty: boolean;
    read: boolean;
    retentionPolicy: RetentionPolicy;
    version: string;
    write: boolean;
}

// @public
export interface MatchConditions {
    ifMatch?: string;
    ifNoneMatch?: string;
}

// @public
export interface Metadata {
    [propertyName: string]: string;
}

// @public
export interface Metrics {
    enabled: boolean;
    includeAPIs?: boolean;
    retentionPolicy?: RetentionPolicy;
    version?: string;
}

// @public
export interface ModificationConditions {
    ifModifiedSince?: Date;
    ifUnmodifiedSince?: Date;
}

// @public
export interface ModifiedAccessConditions extends MatchConditions, ModificationConditions, TagConditions {
}

// @public
export interface ModifiedAccessConditionsModel {
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifTags?: string;
    ifUnmodifiedSince?: Date;
}

// @public
export function newPipeline(credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, pipelineOptions?: StoragePipelineOptions): Pipeline;

// @public
export interface ObjectReplicationPolicy {
    policyId: string;
    rules: ObjectReplicationRule[];
}

// @public
export interface ObjectReplicationRule {
    replicationStatus: ObjectReplicationStatus;
    ruleId: string;
}

// @public
export type ObjectReplicationStatus = "complete" | "failed";

// @public
export interface PageBlobClearPagesHeaders {
    blobSequenceNumber?: number;
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    xMsContentCrc64?: Uint8Array;
}

// @public
export interface PageBlobClearPagesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: PageBlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
}

// @public
export type PageBlobClearPagesResponse = PageBlobClearPagesHeaders;

// @public
export class PageBlobClient extends BlobClient {
    constructor(connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions);
    constructor(url: string, credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: PipelineLike);
    clearPages(offset?: number, count?: number, options?: PageBlobClearPagesOptions): Promise<PageBlobClearPagesResponse>;
    create(size: number, options?: PageBlobCreateOptions): Promise<PageBlobCreateResponse>;
    createIfNotExists(size: number, options?: PageBlobCreateIfNotExistsOptions): Promise<PageBlobCreateIfNotExistsResponse>;
    getPageRanges(offset?: number, count?: number, options?: PageBlobGetPageRangesOptions): Promise<PageBlobGetPageRangesResponse>;
    getPageRangesDiff(offset: number, count: number, prevSnapshot: string, options?: PageBlobGetPageRangesDiffOptions): Promise<PageBlobGetPageRangesDiffResponse>;
    getPageRangesDiffForManagedDisks(offset: number, count: number, prevSnapshotUrl: string, options?: PageBlobGetPageRangesDiffOptions): Promise<PageBlobGetPageRangesDiffResponse>;
    listPageRanges(offset?: number, count?: number, options?: PageBlobListPageRangesOptions): PagedAsyncIterableIterator<PageRangeInfo, PageBlobGetPageRangesResponseModel>;
    listPageRangesDiff(offset: number, count: number, prevSnapshot: string, options?: PageBlobListPageRangesDiffOptions): PagedAsyncIterableIterator<PageRangeInfo, PageBlobGetPageRangesDiffResponseModel>;
    resize(size: number, options?: PageBlobResizeOptions): Promise<PageBlobResizeResponse>;
    startCopyIncremental(copySource: string, options?: PageBlobStartCopyIncrementalOptions): Promise<PageBlobCopyIncrementalResponse>;
    updateSequenceNumber(sequenceNumberAction: SequenceNumberActionType, sequenceNumber?: number, options?: PageBlobUpdateSequenceNumberOptions): Promise<PageBlobUpdateSequenceNumberResponse>;
    uploadPages(body: RequestBodyType, offset: number, count: number, options?: PageBlobUploadPagesOptions): Promise<PageBlobUploadPagesResponse>;
    uploadPagesFromURL(sourceURL: string, sourceOffset: number, destOffset: number, count: number, options?: PageBlobUploadPagesFromURLOptions): Promise<PageBlobUploadPagesFromURLResponse>;
    withSnapshot(snapshot: string): PageBlobClient;
}

// @public
export interface PageBlobCopyIncrementalHeaders {
    clientRequestId?: string;
    copyId?: string;
    copyStatus?: CopyStatusType;
    date?: Date;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export type PageBlobCopyIncrementalResponse = PageBlobCopyIncrementalHeaders;

// @public
export interface PageBlobCreateHeaders {
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    versionId?: string;
}

// @public
export interface PageBlobCreateIfNotExistsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    blobSequenceNumber?: number;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
    immutabilityPolicy?: BlobImmutabilityPolicy;
    legalHold?: boolean;
    metadata?: Metadata;
    tier?: PremiumPageBlobTier | string;
}

// @public
export interface PageBlobCreateIfNotExistsResponse extends PageBlobCreateResponse {
    succeeded: boolean;
}

// @public
export interface PageBlobCreateOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    blobSequenceNumber?: number;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
    immutabilityPolicy?: BlobImmutabilityPolicy;
    legalHold?: boolean;
    metadata?: Metadata;
    tags?: Tags;
    tier?: PremiumPageBlobTier | string;
}

// @public
export type PageBlobCreateResponse = PageBlobCreateHeaders;

// @public
export interface PageBlobGetPageRangesDiffForManagedDisksInPagesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    count: number;
    offset: number;
    prevSnapshotUrl: string;
}

// @public
export interface PageBlobGetPageRangesDiffHeaders {
    blobContentLength?: number;
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface PageBlobGetPageRangesDiffOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    range?: string;
}

// @public
export interface PageBlobGetPageRangesDiffResponse extends PageList, PageBlobGetPageRangesDiffHeaders {
}

// Warning: (ae-forgotten-export) The symbol "PageList" needs to be exported by the entry point index.d.ts
//
// @public
export type PageBlobGetPageRangesDiffResponseModel = PageBlobGetPageRangesDiffHeaders & PageList_2;

// @public
export interface PageBlobGetPageRangesHeaders {
    blobContentLength?: number;
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface PageBlobGetPageRangesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
}

// @public
export interface PageBlobGetPageRangesResponse extends PageList, PageBlobGetPageRangesHeaders {
}

// @public
export type PageBlobGetPageRangesResponseModel = PageBlobGetPageRangesHeaders & PageList_2;

// @public
export interface PageBlobListPageRangesDiffOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
}

// @public
export interface PageBlobListPageRangesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
}

// @public
export interface PageBlobRequestConditions extends BlobRequestConditions, SequenceNumberAccessConditions {
}

// @public
export interface PageBlobResizeHeaders {
    blobSequenceNumber?: number;
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface PageBlobResizeOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    encryptionScope?: string;
}

// @public
export type PageBlobResizeResponse = PageBlobResizeHeaders;

// @public
export interface PageBlobStartCopyIncrementalOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface PageBlobUpdateSequenceNumberHeaders {
    blobSequenceNumber?: number;
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface PageBlobUpdateSequenceNumberOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
}

// @public
export type PageBlobUpdateSequenceNumberResponse = PageBlobUpdateSequenceNumberHeaders;

// @public
export interface PageBlobUploadPagesFromURLHeaders {
    blobSequenceNumber?: number;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    xMsContentCrc64?: Uint8Array;
}

// @public
export interface PageBlobUploadPagesFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: PageBlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
    sourceAuthorization?: HttpAuthorization;
    sourceConditions?: MatchConditions & ModificationConditions;
    sourceContentCrc64?: Uint8Array;
    sourceContentMD5?: Uint8Array;
}

// @public
export type PageBlobUploadPagesFromURLResponse = PageBlobUploadPagesFromURLHeaders;

// @public
export interface PageBlobUploadPagesHeaders {
    blobSequenceNumber?: number;
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    xMsContentCrc64?: Uint8Array;
}

// @public
export interface PageBlobUploadPagesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: PageBlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
    onProgress?: (progress: TransferProgressEvent) => void;
    transactionalContentCrc64?: Uint8Array;
    transactionalContentMD5?: Uint8Array;
}

// @public
export type PageBlobUploadPagesResponse = PageBlobUploadPagesHeaders;

// @public
export interface PageList {
    clearRange?: Range_2[];
    pageRange?: Range_2[];
}

// @public (undocumented)
export interface PageRangeInfo {
    // (undocumented)
    end: number;
    // (undocumented)
    isClear: boolean;
    // (undocumented)
    start: number;
}

// @public
export interface ParsedBatchResponse {
    subResponses: BatchSubResponse[];
    subResponsesFailedCount: number;
    subResponsesSucceededCount: number;
}

// @public
export class Pipeline implements PipelineLike {
    constructor(pipelineContext: Pipeline_2, options?: PipelineOptions);
    readonly options: PipelineOptions;
    readonly pipelineContext: Pipeline_2;
    // Warning: (ae-forgotten-export) The symbol "StorageClientOptionalParams" needs to be exported by the entry point index.d.ts
    toServiceClientOptions(): StorageClientOptionalParams;
}

// @public
export interface PipelineLike {
    options: PipelineOptions;
    pipelineContext: Pipeline_2;
    toServiceClientOptions(): StorageClientOptionalParams;
}

// @public
export interface PipelineOptions {
    httpClient?: HttpClient;
}

export { PipelinePolicy }

export { PipelineRequest }

export { PipelineResponse }

export { PollerLike }

export { PollOperationState }

// @public
export enum PremiumPageBlobTier {
    P10 = "P10",
    P15 = "P15",
    P20 = "P20",
    P30 = "P30",
    P4 = "P4",
    P40 = "P40",
    P50 = "P50",
    P6 = "P6",
    P60 = "P60",
    P70 = "P70",
    P80 = "P80"
}

// @public
export type PublicAccessType = "container" | "blob";

// @public
interface Range_2 {
    count?: number;
    offset: number;
}
export { Range_2 as Range }

// @public
export type RehydratePriority = "High" | "Standard";

export { RequestBodyType }

export { RestError }

// @public
export interface RetentionPolicy {
    days?: number;
    enabled: boolean;
}

// @public
export interface SasIPRange {
    end?: string;
    start: string;
}

// @public
export enum SASProtocol {
    Https = "https",
    HttpsAndHttp = "https,http"
}

// @public
export class SASQueryParameters {
    constructor(version: string, signature: string, permissions?: string, services?: string, resourceTypes?: string, protocol?: SASProtocol, startsOn?: Date, expiresOn?: Date, ipRange?: SasIPRange, identifier?: string, resource?: string, cacheControl?: string, contentDisposition?: string, contentEncoding?: string, contentLanguage?: string, contentType?: string, userDelegationKey?: UserDelegationKey, preauthorizedAgentObjectId?: string, correlationId?: string, encryptionScope?: string);
    constructor(version: string, signature: string, options?: SASQueryParametersOptions);
    readonly cacheControl?: string;
    readonly contentDisposition?: string;
    readonly contentEncoding?: string;
    readonly contentLanguage?: string;
    readonly contentType?: string;
    readonly correlationId?: string;
    readonly encryptionScope?: string;
    readonly expiresOn?: Date;
    readonly identifier?: string;
    get ipRange(): SasIPRange | undefined;
    readonly permissions?: string;
    readonly preauthorizedAgentObjectId?: string;
    readonly protocol?: SASProtocol;
    readonly resource?: string;
    readonly resourceTypes?: string;
    readonly services?: string;
    readonly signature: string;
    readonly startsOn?: Date;
    toString(): string;
    readonly version: string;
}

// @public
export interface SASQueryParametersOptions {
    cacheControl?: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentType?: string;
    correlationId?: string;
    encryptionScope?: string;
    expiresOn?: Date;
    identifier?: string;
    ipRange?: SasIPRange;
    permissions?: string;
    preauthorizedAgentObjectId?: string;
    protocol?: SASProtocol;
    resource?: string;
    resourceTypes?: string;
    services?: string;
    startsOn?: Date;
    userDelegationKey?: UserDelegationKey;
}

// @public
export interface SequenceNumberAccessConditions {
    ifSequenceNumberEqualTo?: number;
    ifSequenceNumberLessThan?: number;
    ifSequenceNumberLessThanOrEqualTo?: number;
}

// @public
export type SequenceNumberActionType = "max" | "update" | "increment";

// @public
export interface ServiceFilterBlobsHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceFindBlobByTagsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceFindBlobsByTagsSegmentResponse = FilterBlobSegment & ServiceFilterBlobsHeaders;

// @public
export interface ServiceGenerateAccountSasUrlOptions {
    encryptionScope?: string;
    ipRange?: SasIPRange;
    protocol?: SASProtocol;
    startsOn?: Date;
    version?: string;
}

// @public
export interface ServiceGetAccountInfoHeaders {
    accountKind?: AccountKind;
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    isHierarchicalNamespaceEnabled?: boolean;
    requestId?: string;
    skuName?: SkuName;
    version?: string;
}

// @public
export interface ServiceGetAccountInfoOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceGetAccountInfoResponse = ServiceGetAccountInfoHeaders;

// @public
export interface ServiceGetPropertiesHeaders {
    clientRequestId?: string;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceGetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceGetPropertiesResponse = ServiceGetPropertiesHeaders & BlobServiceProperties;

// @public
export interface ServiceGetStatisticsHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceGetStatisticsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceGetStatisticsResponse = ServiceGetStatisticsHeaders & BlobServiceStatistics;

// @public
export interface ServiceGetUserDelegationKeyHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceGetUserDelegationKeyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceGetUserDelegationKeyResponse = UserDelegationKey & ServiceGetUserDelegationKeyHeaders;

// @public
export interface ServiceListContainersOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    includeDeleted?: boolean;
    includeMetadata?: boolean;
    includeSystem?: boolean;
    prefix?: string;
}

// @public
export interface ServiceListContainersSegmentHeaders {
    clientRequestId?: string;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export type ServiceListContainersSegmentResponse = ServiceListContainersSegmentHeaders & ListContainersSegmentResponse;

// @public
export interface ServiceRenameContainerOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    sourceCondition?: LeaseAccessConditions;
}

// @public
export interface ServiceSetPropertiesHeaders {
    clientRequestId?: string;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceSetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceSetPropertiesResponse = ServiceSetPropertiesHeaders;

// @public
export interface ServiceSubmitBatchHeaders {
    clientRequestId?: string;
    contentType?: string;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceSubmitBatchOptionalParamsModel extends coreClient.OperationOptions {
    requestId?: string;
    timeoutInSeconds?: number;
}

// @public
export type ServiceSubmitBatchResponseModel = ServiceSubmitBatchHeaders & {
    blobBody?: Promise<Blob>;
    readableStreamBody?: NodeJS.ReadableStream;
};

// @public
export interface ServiceUndeleteContainerOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    // @deprecated
    destinationContainerName?: string;
}

// @public
export interface SignedIdentifier {
    accessPolicy: {
        startsOn?: Date;
        expiresOn?: Date;
        permissions?: string;
    };
    id: string;
}

// @public
export interface SignedIdentifierModel {
    accessPolicy: AccessPolicy;
    id: string;
}

// @public
export type SkuName = "Standard_LRS" | "Standard_GRS" | "Standard_RAGRS" | "Standard_ZRS" | "Premium_LRS";

// @public
export interface StaticWebsite {
    defaultIndexDocumentPath?: string;
    enabled: boolean;
    errorDocument404Path?: string;
    indexDocument?: string;
}

// @public
export enum StorageBlobAudience {
    DiskComputeOAuthScopes = "https://disk.compute.azure.com/.default",
    StorageOAuthScopes = "https://storage.azure.com/.default"
}

// @public
export class StorageBrowserPolicy implements PipelinePolicy {
    constructor();
    // (undocumented)
    name: string;
    sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse>;
}

// @public
export const StorageOAuthScopes: string | string[];

// @public
export interface StoragePipelineOptions {
    audience?: string | string[];
    httpClient?: HttpClient;
    keepAliveOptions?: KeepAliveOptions;
    proxyOptions?: ProxySettings;
    retryOptions?: StorageRetryOptions;
    userAgentOptions?: UserAgentPolicyOptions;
}

// @public
export interface StorageRetryOptions {
    readonly maxRetryDelayInMs?: number;
    readonly maxTries?: number;
    readonly retryDelayInMs?: number;
    readonly retryPolicyType?: StorageRetryPolicyType;
    readonly secondaryHost?: string;
    readonly tryTimeoutInMs?: number;
}

// @public
export class StorageRetryPolicy implements PipelinePolicy {
    constructor(retryOptions?: StorageRetryOptions);
    protected attemptSendRequest(request: PipelineRequest, next: SendRequest, secondaryHas404: boolean, attempt: number): Promise<PipelineResponse>;
    // (undocumented)
    readonly name = "StorageRetryPolicy";
    sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse>;
    protected shouldRetry(isPrimaryRetry: boolean, attempt: number, response?: PipelineResponse, err?: RestError): boolean;
}

// @public
export enum StorageRetryPolicyType {
    EXPONENTIAL = 0,
    FIXED = 1
}

// @public
export class StorageSharedKeyCredential extends Credential_2 {
    constructor(accountName: string, accountKey: string);
    readonly accountName: string;
    computeHMACSHA256(stringToSign: string): string;
    create(): StorageSharedKeyCredentialPolicy;
}

// @public
export class StorageSharedKeyCredentialPolicy extends CredentialPolicy {
    constructor(crediential: StorageSharedKeyCredential);
    readonly credential: StorageSharedKeyCredential;
    // (undocumented)
    readonly name = "StorageSharedKeyCredentialPolicy";
    protected signRequest(request: PipelineRequest): PipelineRequest;
}

// @public
export interface TagConditions {
    tagConditions?: string;
}

// @public
export type Tags = Record<string, string>;

// @public
export interface UserDelegationKey {
    signedExpiresOn: Date;
    signedObjectId: string;
    signedService: string;
    signedStartsOn: Date;
    signedTenantId: string;
    signedVersion: string;
    value: string;
}

// @public
export interface UserDelegationKeyModel {
    signedExpiresOn: string;
    signedObjectId: string;
    signedService: string;
    signedStartsOn: string;
    signedTenantId: string;
    signedVersion: string;
    value: string;
}

// (No @packageDocumentation comment for this package)

```
